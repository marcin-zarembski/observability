PUT _watcher/watch/admin_index_usage_every_15m
{
  "trigger": { "schedule": { "interval": "15m" } },
  "input": {
    "chain": {
      "inputs": [
        {
          "prev": {
            "search": {
              "request": {
                "indices": ["admin-index-usage"],
                "body": {
                  "size": 0,
                  "aggs": {
                    "by_index": {
                      "terms": { "field": "index", "size": 10000 },
                      "aggs": {
                        "latest": {
                          "top_hits": {
                            "size": 1,
                            "sort": [ { "updated_at": { "order": "desc" } } ],
                            "_source": {
                              "includes": [
                                "index",
                                "last_write_at",
                                "last_read_at",
                                "counters.index_total",
                                "counters.delete_total",
                                "counters.search_query_total",
                                "counters.get_total"
                              ]
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        {
          "stats": {
            "http": {
              "request": {
                "scheme": "https",
                "host": "ap-fanves121p",
                "port": 9200,
                "method": "GET",
                "path": "/_stats/store,docs,indexing,search,get?filter_path=indices.*.total.store.size_in_bytes,indices.*.total.docs.count,indices.*.total.indexing.index_total,indices.*.total.indexing.delete_total,indices.*.total.search.query_total,indices.*.total.get.total"
              }
            }
          }
        },
        {
          "list": {
            "http": {
              "request": {
                "scheme": "https",
                "host": "ap-fanves121p",
                "port": 9200,
                "method": "GET",
                "path": "/_cat/indices?format=json&h=index&expand_wildcards=open,hidden"
              }
            }
          }
        },
        {
          "creations": {
            "http": {
              "request": {
                "scheme": "https",
                "host": "ap-fanves121p",
                "port": 9200,
                "method": "GET",
                "path": "/_all/_settings?filter_path=*.settings.index.creation_date"
              }
            }
          }
        }
      ]
    }
  },
  "transform": {
    "script": {
      "lang": "painless",
      "source": """
        boolean includeSystem = false;
        boolean alsoIndexRaw  = false;   // set true if you also want per-run history to admin-index-usage-raw

        String now = ctx.trigger.triggered_time.toInstant().toString();

        def prevMap = new HashMap();
        if (ctx.payload.prev != null && ctx.payload.prev.aggregations != null) {
          for (def b : ctx.payload.prev.aggregations.by_index.buckets) {
            def hit = b.latest.hits.hits[0];
            def src = hit._source;
            prevMap.put(src.index, [
              "index_total":        (src.counters != null && src.counters.index_total        != null ? src.counters.index_total        : 0L),
              "delete_total":       (src.counters != null && src.counters.delete_total       != null ? src.counters.delete_total       : 0L),
              "search_query_total": (src.counters != null && src.counters.search_query_total != null ? src.counters.search_query_total : 0L),
              "get_total":          (src.counters != null && src.counters.get_total          != null ? src.counters.get_total          : 0L),
              "last_write_at":       src.last_write_at,
              "last_read_at":        src.last_read_at
            ]);
          }
        }

        def listRoot = (ctx.payload.list != null && ctx.payload.list.body != null) ? ctx.payload.list.body : ctx.payload.list;
        if (listRoot == null) { listRoot = new ArrayList(); }

        def allowed = new HashSet();
        for (def row : listRoot) {
          def name = row.index;
          if (name == null) { continue; }
          if (!includeSystem && name.startsWith(".")) { continue; }
          allowed.add(name);
        }

        def statsRoot = (ctx.payload.stats != null && ctx.payload.stats.body != null) ? ctx.payload.stats.body : ctx.payload.stats;
        def stats = (statsRoot != null && statsRoot.indices != null) ? statsRoot.indices : new HashMap();

        def creations = (ctx.payload.creations != null && ctx.payload.creations.body != null) ? ctx.payload.creations.body : ctx.payload.creations;
        if (creations == null) { creations = new HashMap(); }

        def docs = new ArrayList();
        def rawDocs = new ArrayList();

        for (def entry : stats.entrySet()) {
          String idx = entry.getKey();
          if (!allowed.contains(idx)) { continue; }

          def tot = entry.getValue().total;

          long sizeB   = (tot != null && tot.store  != null && tot.store.size_in_bytes   != null ? tot.store.size_in_bytes   : 0L);
          long docsCnt = (tot != null && tot.docs   != null && tot.docs.count            != null ? tot.docs.count            : 0L);
          long cIndex  = (tot != null && tot.indexing != null && tot.indexing.index_total  != null ? tot.indexing.index_total  : 0L);
          long cDelete = (tot != null && tot.indexing != null && tot.indexing.delete_total != null ? tot.indexing.delete_total : 0L);
          long cSearch = (tot != null && tot.search   != null && tot.search.query_total    != null ? tot.search.query_total    : 0L);
          long cGet    = (tot != null && tot.get      != null && tot.get.total             != null ? tot.get.total             : 0L);

          String createdAt = null;
          def cnode = creations[idx];
          if (cnode != null && cnode.settings != null && cnode.settings.index != null && cnode.settings.index.creation_date != null) {
            try {
              long ms = Long.parseLong(cnode.settings.index.creation_date.toString());
              createdAt = Instant.ofEpochMilli(ms).toString();
            } catch (Exception e) { }
          }

          def prev = prevMap.get(idx);

          String lastWrite = (prev != null ? (String)prev.last_write_at : null);
          String lastRead  = (prev != null ? (String)prev.last_read_at  : null);

          boolean isFirst = (prev == null);
          boolean isReset = false;

          if (!isFirst) {
            long pIdx = (prev.index_total        instanceof Number ? ((Number)prev.index_total).longValue()        : 0L);
            long pDel = (prev.delete_total       instanceof Number ? ((Number)prev.delete_total).longValue()       : 0L);
            long pSea = (prev.search_query_total instanceof Number ? ((Number)prev.search_query_total).longValue() : 0L);
            long pGet = (prev.get_total          instanceof Number ? ((Number)prev.get_total).longValue()          : 0L);

            isReset = (cIndex < pIdx) || (cDelete < pDel) || (cSearch < pSea) || (cGet < pGet);

            if (!isReset) {
              if (cIndex > pIdx || cDelete > pDel) { lastWrite = now; }
              if (cSearch > pSea || cGet > pGet)   { lastRead  = now; }
            }
          }

          def doc = new HashMap();
          doc.put("index", idx);
          doc.put("size_bytes", sizeB);
          doc.put("docs_count", docsCnt);
          doc.put("created_at", createdAt);
          doc.put("last_write_at", lastWrite);
          doc.put("last_read_at",  lastRead);
          doc.put("updated_at", now);
          doc.put("counters", [
            "index_total":        cIndex,
            "delete_total":       cDelete,
            "search_query_total": cSearch,
            "get_total":          cGet
          ]);

          docs.add(doc);

          if (alsoIndexRaw) {
            def raw = new HashMap(doc);
            raw.put("@timestamp", now);
            rawDocs.add(raw);
          }
        }

        return ["docs": docs, "rawDocs": rawDocs];
      """
    }
  },
  "actions": {
    "bulk_snapshot": {
      "http": {
        "request": {
          "scheme": "https",
          "host": "ap-fanves121p",
          "port": 9200,
          "method": "POST",
          "path": "/_bulk?refresh=false",
          "headers": { "Content-Type": "application/x-ndjson" },
          "body": "{{#ctx.payload.docs}}{\"index\":{\"_index\":\"admin-index-usage\",\"_id\":\"{{index}}\"}}\n{{#toJson}}{{.}}{{/toJson}}\n{{/ctx.payload.docs}}"
        }
      }
    },
    "bulk_raw_history": {
      "condition": { "script": "return params.enable && ctx.payload.rawDocs != null && !ctx.payload.rawDocs.isEmpty();" ,
                     "params": { "enable": false } },
      "http": {
        "request": {
          "scheme": "https",
          "host": "ap-fanves121p",
          "port": 9200,
          "method": "POST",
          "path": "/_bulk?refresh=false",
          "headers": { "Content-Type": "application/x-ndjson" },
          "body": "{{#ctx.payload.rawDocs}}{\"index\":{\"_index\":\"admin-index-usage-raw\"}}\n{{#toJson}}{{.}}{{/toJson}}\n{{/ctx.payload.rawDocs}}"
        }
      }
    },
    "log_summary": {
      "logging": { "text": "admin-index-usage: bulked {{ctx.payload.docs.size()}} docs (15m schedule)" }
    }
  },
  "metadata": {
    "description": "Every 15 min snapshot of index metrics with heuristic last_read/last_write, first-run nulls, and counter-reset protection; bulk indexing."
  },
  "throttle_period": "0s"
}
